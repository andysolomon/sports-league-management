---
description: 
globs: 
alwaysApply: true
---
# Salesforce Development Rules for Cursor AI

## Project Context
This is a Salesforce project using Lightning Web Components (LWC), Apex, and Salesforce DX tools. Follow Salesforce best practices and modern development patterns.

## File Structure and Naming Conventions

### Lightning Web Components (LWC)
- Use camelCase for component names (e.g., `helloWorld`) which maps to kebab-case in HTML (`<c-hello-world>`)
- LWC files should be in `force-app/main/default/lwc/` directory
- Each component has 3 required files: `.js`, `.html`, `.js-meta.xml`
- Optional files: `.css`, `.svg`, test files in `__tests__/` subdirectory
- Test files should end with `.test.js` in the `__tests__` folder
- Use `@api` for public properties, `@track` for reactive private properties
- Import modules using `import` statements from `@salesforce/` namespaces

### Apex Classes
- Use PascalCase for class names starting with a capital letter
- Use CamelCase for method names starting with a lowercase letter
- Place in `force-app/main/default/classes/` directory
- Each class should have a corresponding `.cls-meta.xml` file
- Use proper access modifiers (`public`, `private`, `global`, `protected`)
- Follow naming conventions: `b2cpmtp_` prefix for this project
- Use descriptive and consistent naming conventions
- Avoid acronyms and single-character variable names

### Triggers
- Use PascalCase for trigger names starting with a capital letter
- Limit to one trigger per object
- Use a trigger framework to enforce best practices
- Place in `force-app/main/default/triggers/` directory

### Metadata Files
- All `.js-meta.xml` files must have proper `apiVersion` (use latest stable)
- Set `isExposed` to `true` for components used in Lightning App Builder
- Define proper `targets` for where components can be used
- Always include all necessary related files when creating Salesforce assets

## Code Quality and Best Practices

### General Code Cleanliness
- Write clean, concise, and self-documenting code
- Use descriptive and consistent naming conventions
- Keep methods short; delegate complex logic to private methods
- Remove unused code promptly to avoid confusion
- Avoid hardcoding IDs; use Schema methods or constants
- Replace repeated strings with constants for better maintainability
- Keep code within 120 columns for readability
- Remove trailing whitespace
- Use formatting tools like Prettier in VS Code

### Lightning Web Components
- Always use `import { LightningElement, api, track, wire } from 'lwc'`
- Use lifecycle hooks appropriately: `connectedCallback()`, `disconnectedCallback()`, `renderedCallback()`
- Handle errors gracefully with try-catch blocks
- Use `@wire` for reactive data from Salesforce
- Dispatch custom events using `new CustomEvent()` with proper detail structure
- Use `this.template.querySelector()` for DOM access
- Implement proper event handling patterns
- Use Lightning Design System (SLDS) classes for styling
- Follow Lightning Base Components when available instead of custom implementations

### Apex Development

#### Class Design and Access Modifiers
- Explicitly declare sharing settings (`with sharing` or `without sharing`)
- Use appropriate access modifiers:
  - **Public**: For service and controller classes accessible across the org
  - **Private**: For helper methods or classes used internally
  - **Global**: Only for web-service classes or when required by managed packages
- Use proper exception handling with try-catch blocks
- Follow SOQL best practices: avoid queries in loops, use bulk patterns
- Use `@AuraEnabled` for methods called from Lightning components
- Add `cacheable=true` for read-only wire service methods
- Use proper data types and null checks

#### Variable and Container Declaration
- Use descriptive names; avoid acronyms and single-character names
- Declare variables in the narrowest scope possible
- Use `List<TypeName>` instead of `TypeName[]` for clarity
- Mark static variables as final when possible

#### SOQL Queries
- Optimize queries with selective WHERE clauses and indexed fields
- Capitalize SOQL keywords for clarity
- Avoid querying the `Id` field unnecessarily
- Do not perform SOQL or DML operations inside loops
- Enforce field- and object-level security in SOQL queries

#### Loops
- Prefer foreach loops for better readability
- Avoid nested loops when possible
- Do not perform DML, SOQL, SOSL, @future methods, or callouts inside loops

#### Triggers
- Limit to one trigger per object
- Use a trigger framework to enforce best practices
- Avoid recursion by comparing `trigger.old` and `trigger.new` values
- Test triggers with bulk data (200 records)

### Code Formatting

#### Brackets
- Follow "Egyptian style":
  - No line break before the opening brace
  - Line breaks after the opening brace and before/after the closing brace

#### Comments and Documentation
- Use the Apex Docs format for comments
- Document all public methods and properties
- Include file headers specifying the purpose and ownership
- Write self-documenting code; avoid relying solely on comments

### Error Handling
- Use `lightning/platformShowToastEvent` for user notifications
- Log errors using `lightning/logger` for debugging
- Implement proper error boundaries in components
- Display user-friendly error messages
- Use `displayErrorToastMessage` utility when available
- Wrap DML operations in try-catch blocks
- Use custom exceptions for specific scenarios
- Log errors with a custom utility class for debugging

### Security
- Always validate user input
- Use platform security features (CRUD, FLS)
- Sanitize data before display
- Use `@salesforce/userPermissions` to check permissions
- Implement proper access controls in Apex
- Use "with sharing" to respect user permissions unless otherwise required

## Testing Standards

### Jest Testing for LWC
- Create test files in `__tests__/` subdirectory
- Use descriptive test names and organize with `describe` blocks
- Test component behavior, not implementation details
- Mock external dependencies and wire services
- Use `createElement` to instantiate components in tests
- Test event dispatching and handling
- Verify DOM updates and user interactions
- Run tests with `sf force lightning lwc test run`

### Apex Testing
- Test classes should be private
- Use `@isTest` annotation
- Use test data factories for consistent test data
- Avoid the `SeeAllData` annotation
- Use `Test.startTest()` and `Test.stopTest()` to reset governor limits
- Minimize logic within `Test.startTest()` and `Test.stopTest()` blocks
- Create test data within test methods (no @testSetup unless necessary)
- Use proper assertions: `System.assertEquals()`, `System.assertNotEquals()`
- Use new Salesforce Assert Class: https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_class_System_Assert.htm
- Test both positive and negative scenarios
- Include both positive and negative test cases
- Test bulk operations and governor limits
- Aim for 100% code coverage, with a minimum of 90%
- Include assertions to validate behavior
- Use Inversion of Control and dependency injection for mocking
- Avoid directly testing trigger handlers; test triggers instead
- DO NOT MODIFY THE RELATED CLASS TO GET THE TEST CLASS TO PASS

## Salesforce CLI and Development Workflow

### Commands to Use
- `sf project create` for new projects
- `sf lightning dev app` for local development preview
- `sf org create scratch` for scratch orgs
- `sf project deploy start` for deployments
- `sf data query` for SOQL queries
- `sf force lightning lwc test run` for component testing

### Local Development
- Use Local Dev for real-time preview: `sf lightning dev app`
- Enable Local Dev in scratch org settings
- Use hot module reloading for rapid iteration
- Test on both desktop and mobile device types

### Deployment Best Practices
- Always include all necessary related files when creating Salesforce assets
- Use PMD for static code analysis
- Remove `System.Debug` statements before deployment
- Leverage Salesforce CLI for streamlined deployment
- Use collaborative tools to share best practices and code snippets
- Create team standards for naming conventions and reusable components

## TypeScript Support (Developer Preview)
- Use TypeScript v5.4.5+ when enabling TypeScript support
- Set `experimentalDecorators: false` in `tsconfig.json`
- Import types from `@salesforce/lightning-types`
- Compile TypeScript to JavaScript before deployment
- Use proper type annotations for better code quality

## Component Communication Patterns
- Use `@api` properties for parent-to-child communication
- Use custom events for child-to-parent communication
- Use Lightning Message Service for component-to-component communication
- Avoid direct DOM manipulation across component boundaries

## Data Access Patterns
- Use `@wire` for reactive data binding
- Use `lightning/uiRecordApi` for record operations
- Use `lightning/uiListApi` for list views
- Use `lightning/uiObjectInfoApi` for object metadata
- Implement proper loading states and error handling

## Flow Best Practices
- Limit to three flows per object (Before Save, Before Delete, After Save)
- Avoid hardcoding values like `RecordTypeId`
- Prohibit DML and Get Records elements in loops
- Use fault paths for error handling

## Performance Best Practices
- Use `@wire` instead of imperative calls when possible
- Implement proper caching strategies
- Minimize DOM manipulations
- Use proper list rendering with `for:each` or `iterator`
- Avoid unnecessary re-renders
- Design Apex code to handle bulk operations
- Respect Salesforce governor limits (SOQL queries, DML operations, heap size)
- Use batch Apex for large datasets
- Optimize SOQL queries with indexed fields and selective WHERE clauses
- Minimize synchronous operations when asynchronous alternatives are available

## Common Anti-Patterns to Avoid
- Don't use `eval()` or similar dynamic code execution
- Don't directly manipulate the DOM outside of lifecycle hooks
- Don't use synchronous operations that block the UI
- Don't hardcode IDs or metadata references
- Don't ignore error handling
- Don't write SOQL queries inside loops
- Don't use `System.debug()` in production code
- Don't perform DML, SOQL, SOSL, @future methods, or callouts inside loops

## IDE Integration
- Use Visual Studio Code with Salesforce Extension Pack
- Enable ESLint with `@salesforce/eslint-config-lwc`
- Use Prettier for code formatting
- Enable debug mode in Salesforce orgs for development

## File Patterns to Ignore
Add to `.forceignore`:
```
**/__tests__/**
**/node_modules/**
**/*.ts
!**/*.d.ts
```

## Additional References
- [Apex Reference Guide](https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/)
- [PMD Documentation](https://pmd.github.io/)
- [Apex Limits Class](https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_methods_system_limits.htm)
- [Salesforce Assert Class](https://developer.salesforce.com/docs/atlas.en-us.apexref.meta/apexref/apex_class_System_Assert.htm)

## When suggesting code:
1. Always include proper error handling
2. Use modern JavaScript/ES6+ features
3. Follow Salesforce naming conventions
4. Include necessary imports
5. Add comments for complex logic
6. Consider mobile responsiveness
7. Implement proper accessibility features
8. Use Lightning Design System utilities
9. Follow the established patterns in the codebase
10. Ensure bulkification for Apex code
11. Include comprehensive test coverage
12. Follow security best practices
13. Optimize for performance and governor limits 